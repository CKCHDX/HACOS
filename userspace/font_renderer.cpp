#include "font_renderer.h"

// Global font storage (128 ASCII characters, 8x16 bitmap)
static uint8_t g_font_glyphs[128][16];
static bool g_font_initialized = false;

static void init_font_data() {
    if (g_font_initialized) return;
    
    // Initialize all to zero
    for (int c = 0; c < 128; c++) {
        for (int row = 0; row < 16; row++) {
            g_font_glyphs[c][row] = 0x00;
        }
    }
    
    // Define all uppercase letters A-Z
    uint8_t font_data[26][16] = {
        // A (65)
        {0x38, 0x44, 0x82, 0x82, 0x82, 0xFE, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // B (66)
        {0xFC, 0x82, 0x82, 0x82, 0xFC, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xFC, 0x00, 0x00, 0x00, 0x00},
        // C (67)
        {0x3C, 0x42, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00},
        // D (68)
        {0xFC, 0x82, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x82, 0xFC, 0x00, 0x00, 0x00, 0x00},
        // E (69)
        {0xFE, 0x80, 0x80, 0x80, 0xFC, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFE, 0x00, 0x00, 0x00, 0x00},
        // F (70)
        {0xFE, 0x80, 0x80, 0x80, 0xFC, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00},
        // G (71)
        {0x3C, 0x42, 0x80, 0x80, 0x80, 0x8E, 0x82, 0x82, 0x82, 0x82, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00},
        // H (72)
        {0x82, 0x82, 0x82, 0x82, 0xFE, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // I (73)
        {0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x00, 0x00, 0x00},
        // J (74)
        {0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00, 0x00, 0x00, 0x00},
        // K (75)
        {0x82, 0x84, 0x88, 0x90, 0xE0, 0x90, 0x88, 0x84, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // L (76)
        {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFE, 0x00, 0x00, 0x00, 0x00},
        // M (77)
        {0x82, 0xC6, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // N (78)
        {0x82, 0xC2, 0xA2, 0x92, 0x8A, 0x86, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // O (79)
        {0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00},
        // P (80)
        {0xFC, 0x82, 0x82, 0x82, 0xFC, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00},
        // Q (81)
        {0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x89, 0x46, 0x3D, 0x00, 0x00, 0x00, 0x00},
        // R (82)
        {0xFC, 0x82, 0x82, 0x82, 0xFC, 0x90, 0x88, 0x84, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // S (83)
        {0x3E, 0x41, 0x80, 0x80, 0x40, 0x3C, 0x02, 0x01, 0x01, 0x01, 0x82, 0x7C, 0x00, 0x00, 0x00, 0x00},
        // T (84)
        {0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00},
        // U (85)
        {0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00},
        // V (86)
        {0x82, 0x82, 0x82, 0x82, 0x44, 0x44, 0x44, 0x28, 0x28, 0x28, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00},
        // W (87)
        {0x82, 0x82, 0x82, 0x92, 0x92, 0x92, 0xAA, 0xAA, 0xAA, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00},
        // X (88)
        {0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x28, 0x44, 0x44, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00},
        // Y (89)
        {0x82, 0x82, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00},
        // Z (90)
        {0xFE, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x40, 0x80, 0x80, 0x80, 0xFE, 0x00, 0x00, 0x00, 0x00}
    };
    
    // Copy to global storage (A-Z = ASCII 65-90)
    for (int letter = 0; letter < 26; letter++) {
        for (int row = 0; row < 16; row++) {
            g_font_glyphs[65 + letter][row] = font_data[letter][row];
        }
    }
    
    // Numbers 0-9 (ASCII 48-57)
    uint8_t num_0[] = {0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00};
    uint8_t num_3[] = {0x3C, 0x42, 0x01, 0x01, 0x02, 0x1C, 0x02, 0x01, 0x01, 0x01, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00};
    
    for (int i = 0; i < 16; i++) {
        g_font_glyphs['0'][i] = num_0[i];
        g_font_glyphs['3'][i] = num_3[i];
    }
    
    // Space (32)
    // Already all zeros
    
    g_font_initialized = true;
}

// Empty declaration for compatibility
const uint8_t FontRenderer::FONT_DATA[][16] = {{0}};

FontRenderer::FontRenderer(Renderer& renderer) : m_renderer(renderer) {
    init_font_data();
}

void FontRenderer::drawText(int x, int y, const char* text, Renderer::Color color, int size) {
    int currentX = x;
    
    for (int i = 0; text[i] != '\0'; i++) {
        unsigned char c = (unsigned char)text[i];
        if (c >= 128) continue;
        
        const uint8_t* glyph = g_font_glyphs[c];
        
        // Check if glyph is empty (all zeros) - if so, just skip it
        bool isEmpty = true;
        for (int row = 0; row < 16; row++) {
            if (glyph[row] != 0) {
                isEmpty = false;
                break;
            }
        }
        
        if (!isEmpty) {
            for (int row = 0; row < 16; row++) {
                uint8_t byte = glyph[row];
                for (int col = 0; col < 8; col++) {
                    if (byte & (0x80 >> col)) {
                        for (int sy = 0; sy < size; sy++) {
                            for (int sx = 0; sx < size; sx++) {
                                m_renderer.drawPixel(currentX + col * size + sx, 
                                                    y + row * size + sy, color);
                            }
                        }
                    }
                }
            }
        }
        
        currentX += 8 * size + 2 * size; // Character width + spacing
    }
}

void FontRenderer::drawTextCentered(int y, const char* text, Renderer::Color color, int size) {
    int width = measureText(text, size);
    int x = (m_renderer.width() - width) / 2;
    drawText(x, y, text, color, size);
}

int FontRenderer::measureText(const char* text, int size) {
    int len = 0;
    while (text[len] != '\0') len++;
    return len * (8 * size + 2 * size);
}
